<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\gameobject.js - particles-gl</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="particles-gl"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.9.5</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Kiwi.Plugins.ParticlesGL.html">Kiwi.Plugins.ParticlesGL</a></li>
            
                <li><a href="../classes/StatelessParticles.html">StatelessParticles</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Kiwi.html">Kiwi</a></li>
            
                <li><a href="../modules/Plugins.html">Plugins</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\gameobject.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">

/**

 * @module Kiwi
 * @submodule GameObjects
 * @main StatelessParticles
 */


/**
 * Creates a particle game object
 * @class StatelessParticles
 * @extends Kiwi.Entity
 * @constructor
 * @param {Kiwi.State} state : the state to which the game object belongs
 * @param {Kiwi.Textures.TextureAtlas} atlas : the texture for the particle object
 * @param {number} x : the x position of the game object
 * @param {number} y : the y position of the game object
 * @param {object} config : the particle configuration object
 * @public
 * @return {Kiwi.GameObjects.StatelessParticles}
 */

Kiwi.GameObjects.StatelessParticles = function(state, atlas, x, y, config){
    Kiwi.Entity.call(this,state, x, y);

    return this.constructor(state, atlas, x, y, config);

};
Kiwi.extend(Kiwi.GameObjects.StatelessParticles,Kiwi.Entity);



(function (){
    var protoProps = {

        constructor : function (state, atlas, x, y, config){
            if (typeof x === &quot;undefined&quot;) { x = 0; }
            if (typeof y === &quot;undefined&quot;) { y = 0; }
            if (typeof config === &quot;undefined&quot;) { config = this.defaultConfig; }
         
            this.config = config;
            
            this.randoms = function() {
                var arr = []
                for (var i =0;i &lt; 5000;i++) {
                    arr.push(Math.random())
                }
                return arr
            }();

            if (this.game.renderOption === Kiwi.RENDERER_WEBGL) {
                this.glRenderer = this.game.renderer.requestRendererInstance(&quot;StatelessParticleRenderer&quot;, { config: this.config });
            }

            if (typeof atlas == &quot;undefined&quot;) {
                console.error(&#x27;A Texture Atlas was not passed when instantiating a new StatelessParticles.&#x27;);
                this.willRender = false;
                this.active = false;
                return;
            }

            //Set coordinates and texture
            this.atlas = atlas;
            this.cellIndex = this.atlas.cellIndex;
            this.width = atlas.cells[0].w;
            this.height = atlas.cells[0].h;
            this.transform.rotPointX = this.width / 2;
            this.transform.rotPointY = this.height / 2;
            this.box = this.components.add(new Kiwi.Components.Box(this, x, y, this.width, this.height));

        },

        /**
        * The default configuration object.
        * @property defaultConfig
        * @type object
        */
        defaultConfig : {
            &quot;numParts&quot;: 20,
            &quot;posOffsetX&quot;: 0,
            &quot;posOffsetY&quot;: 0,
            &quot;posRadius&quot;: 50,
            &quot;posRadialStart&quot;: 4.363323129985823,
            &quot;posRadialEnd&quot;: 5.061454830783556,
            &quot;posWidth&quot;: 100,
            &quot;posHeight&quot;: 100,
            &quot;posAngle&quot;: 0,
            &quot;posLength&quot;: 100,
            &quot;posConstrainRect&quot;: true,
            &quot;posConstrainRadial&quot;: true,
            &quot;posShape&quot;: &quot;radial&quot;,
            &quot;maxVel&quot;: 100,
            &quot;minVel&quot;: 70,
            &quot;velConstrainRect&quot;: false,
            &quot;velConstrainRadial&quot;: false,
            &quot;velShape&quot;: &quot;line&quot;,
            &quot;velOffsetX&quot;: 0,
            &quot;velOffsetY&quot;: 0,
            &quot;velAngMin&quot;: -2,
            &quot;velAngMax&quot;: +2,
            &quot;velRadius&quot;: 100,
            &quot;velRadialStart&quot;: 0,
            &quot;velRadialEnd&quot;: 6.283185307179586,
            &quot;velWidth&quot;: 100,
            &quot;velHeight&quot;: 100,
            &quot;velAngle&quot;: 0,
            &quot;velLength&quot;: 30,
            &quot;minStartTime&quot;: 1,
            &quot;maxStartTime&quot;: 6,
            &quot;minLifespan&quot;: 3,
            &quot;maxLifespan&quot;: 5,
            &quot;gravityX&quot;: -20,
            &quot;gravityY&quot;: 30,
            &quot;startSize&quot;: 4,
            &quot;endSize&quot;: 150,
            &quot;loop&quot;: true,
            &quot;colEnvKeyframes&quot;: [
                0.5,
                0.6
            ],
            &quot;alpha&quot;: &quot;1&quot;,
            &quot;colEnv0&quot;: [
                1,
                0,
                0
            ],
            &quot;colEnv1&quot;: [
                1,
                1,
                0
            ],
            &quot;colEnv2&quot;: [
                1,
                1,
                1
            ],
            &quot;colEnv3&quot;: [
                0,
                0,
                0
            ],
            &quot;alphaGradient&quot;: [
                1,
                1,
                1,
                0
            ],
            &quot;alphaStops&quot;: [
                0.3,
                0.7
            ]
        },

        /**
        * Returns whether the particle system has started emitting
        * @property started
        * @type boolean
        * @public
        */
        started : false,

        /**
         * The type of object that this is.
         * @method objType
         * @return string
         * @public
         */
        objType : function () {
            return &quot;StatelessParticles&quot;;
        },

        /**
        * An array of vectors that conatains generated velocities if useDrawingVectors is true. Used by the particle editor.
        * @property drawingVectors
        * @type array
        * @private
        */
        drawingVectors : [],

        /**
        * If true, velocity vectors will be stored on particle generation. Used by the particle editor.
        * @property useDrawingVectors
        * @type boolean
        * @private
        */
        useDrawingVectors : false,

        /**
        * A function delegated to return a random number. Used by the particle editor.
        * @property rnd
        * @type function
        * @private
        */
        rnd : null,

        /**
        * If useRandoms is true, This array will contain pregenerate random numbers which will be used every new generation refresh. Used by the particle editor.
        * @property randoms
        * @type array
        * @private
        */
        randoms : [],

        /**
        * If true, pregenerate random numbers. Used by the particle editor.
        * @property useRandoms
        * @type boolean
        * @private
        */
        useRandoms : false,

        /**
        * The number of random numbers to generate if useRandoms is true.
        * @property numRandoms
        * @type number
        * @private
        */
        numRandoms: 5000,
        
        /**
        * The index of the next random number in useRandoms. Used by the particle editor.
        * @property nextRandomIndex
        * @type number
        * @private
        */
        nextRandomIndex : -1,
    
        /**
        * The maximum loop length of the system.
        * @property loopLength
        * @type number
        * @private
        */
        loopLength:0,

        /**
         * Get the next random number from the randoms list. Used by the particle editor.
         * @method nextRandom
         * @return number
         * @private
         */
        nextRandom : function () {
            this.nextRandomIndex++;
            if (this.nextRandomIndex &gt;= this.numRandoms) this.nextRandomIndex =-1;
            return this.randoms[this.nextRandomIndex];
        },

        /**
         * Starts the system emitting particles. Particles will be regenerated each time.
         * @method startEmitting
         * @param {boolean} loop : Set to true for continuous looping. Overrides and updates the config loop setting. 
         * @param {boolean} removeOnComplete : if not looping, then the gameobject will destroy itself after one full emission cycle.
         * @param {number} numParts : the number of particles to generate, set on the config object - if not provided the current config value will be used 
         * @public
         */
        startEmitting : function (loop,removeOnComplete,numParts) {
            if (typeof loop === &quot;undefined&quot;) { loop = true; }
            if (typeof removeOnComplete === &quot;undefined&quot;) { removeOnComplete = false }
            if (typeof numParts === &quot;undefined&quot;) { numParts = this.config.numParts; }

            this.config.numParts = numParts;
            this.config.loop = loop;
            
            this.glRenderer.resetTime();
            this.glRenderer.resetPauseTime();
            
            this.setConfig(this.config,true,true);
                      
            if (!loop &amp;&amp; removeOnComplete) {
                this.scheduleRemoval(this.loopLength * 1000);
            }

            this.started = true;
        
        },
        
        /**
         * Stops the system from emitting particles.
         * @method stopEmitting
         * @param {boolean} immediate : stops the emitter and removes any existing particles.
         * @param {boolean} remove : if true the gameobject will mark itself for removal either immediately, or after a completed cycle.  
         * @public
         */
        stopEmitting : function(immediate,remove) {
            
            if (typeof immediate === &quot;undefined&quot;) { immediate = false; }
            if (typeof remove === &quot;undefined&quot;) { remove = false; }

            if (immediate &amp;&amp; remove) {
              this.remove();
            } else if (immediate &amp;&amp; !remove) {
              this.started = false;
            } else if (!immediate &amp;&amp; !remove) {
              this.glRenderer.pause();
              this.started = false;
            } else if (!immediate &amp;&amp; remove) {
              this.config.loop = false;
              this.scheduleRemoval(this.loopLength * 1000);
            }          
        

        },

        /**
         * Marks the gameobject for removal after a provided number of milliseconds.
         * @method scheduleRemoval
         * @param {boolean} milliseconds : the delahy time in milliseconds before being marked for removal.
         * @public
         */
        scheduleRemoval: function (milliseconds) {
            var that = this;
            setTimeout(function(milliseconds) {
                that.remove.call(that);
            },milliseconds)

        },

        /**
         * Immediately marks the gameobject for removal.
         * @method remove
         * @public
         */
        remove : function() {
            this.glRenderer.destroy();  
            this.exists = false;
        },


        /**
        * Sets the configuration object and optionally regenerates particles and sets runtime properties.
        * @method setConfig
        * @param {object} config : the new configuration object
        * @param {boolean} doGenerate : immediately regenerate particles
        * @param {boolean} doUniforms : apply runtime properties
        * @public
        */
        setConfig : function (config,doGenerate,doUniforms) {
            this.config = config;
            this.glRenderer.setConfig(config);
            if (doGenerate) this._generateParticles();
            if (doUniforms) this.glRenderer._setConfigUniforms();
        },


        /**
        * Generates particles based on configuration object.
        * @method _generateParticles
        * @private
        */
        _generateParticles : function () {
            if (this.useRandoms)
                this.rnd = this.nextRandom;
            else
                this.rnd = Math.random;

            this.nextRandomIndex = -1;
            var vertexItems = [];
            
            var cfg = this.config;

            this.drawingVectors = [];


            for (var i =0; i &lt; cfg.numParts;i++) {
                //calculate pos
                var posSeed = {x:0,y:0};
                var pos = {x:0,y:0};
                var vel = {x:cfg.velOffsetX,y:cfg.velOffsetY};
                var velSeed = {x:0,y:0};


                switch (cfg.posShape) {
                    case &quot;radial&quot;:
                        if (cfg.posRandomRadial)
                            posSeed = (cfg.posConstrainRadial) ? this.randomPointCirclePerimeter( cfg.posRadialStart,cfg.posRadialEnd): this.randomPointCircle( cfg.posRadialStart,cfg.posRadialEnd);
                        else
                            posSeed = (cfg.posConstrainRadial) ? this.regularPointCirclePerimeter( cfg.posRadialStart,cfg.posRadialEnd,i,cfg.numParts-1): this.randomPointCircle( cfg.posRadialStart,cfg.posRadialEnd);
                        pos.x  = posSeed.x * cfg.posRadius;
                        pos.y  = posSeed.y * cfg.posRadius;

                        break;

                    case &quot;rectangle&quot;:
                        posSeed = (cfg.posConstrainRect) ? this.randomPointRectPerimeter() : this.randomPointRect();
                        pos.x += posSeed.x * cfg.posWidth;
                        pos.y += posSeed.y * cfg.posHeight;
                        break;

                    case &quot;line&quot;:
                        if (cfg.posRandomLine)
                            posSeed = this.randomPointLine(cfg.posAngle);
                        else
                            posSeed = this.regularPointLine(cfg.posAngle,i,cfg.numParts-1);
                        pos.x += posSeed.x * cfg.posLength;
                        pos.y += posSeed.y * cfg.posLength;
                        break;

                    case &quot;point&quot; :

                        break;
                }

                switch (cfg.velShape) {
                    case &quot;center&quot;:
                        var direction = posSeed;
                        var magnitude = cfg.minVel + this.rnd() * (cfg.maxVel - cfg.minVel)
                        vel.x = direction.x * magnitude ;
                        vel.y = direction.y * magnitude ;
                        break;

                    case &quot;radial&quot;:
                        if (cfg.velRandomRadial)
                            velSeed = (cfg.velConstrainRadial) ? this.randomPointCirclePerimeter( cfg.velRadialStart,cfg.velRadialEnd): this.randomPointCircle( cfg.velRadialStart,cfg.velRadialEnd);
                        else
                            velSeed = (cfg.velConstrainRadial) ? this.regularPointCirclePerimeter( cfg.velRadialStart,cfg.velRadialEnd,i,cfg.numParts-1): this.randomPointCircle( cfg.velRadialStart,cfg.velRadialEnd);

                        vel.x += velSeed.x * cfg.velRadius;
                        vel.y += velSeed.y * cfg.velRadius;

                        break;

                    case &quot;rectangle&quot;:
                        velSeed = (cfg.velConstrainRect) ? this.randomPointRectPerimeter() : this.randomPointRect();

                        vel.x += velSeed.x * cfg.velWidth;
                        vel.y += velSeed.y * cfg.velHeight;
                        break;

                    case &quot;line&quot;:
                        if (cfg.velRandomLine)
                            velSeed = this.randomPointLine(cfg.velAngle);
                        else
                            velSeed = this.regularPointLine(cfg.velAngle,i,cfg.numParts -1);
                        vel.x += velSeed.x * cfg.velLength;
                        vel.y += velSeed.y * cfg.velLength;
                        break;

                    case &quot;point&quot; :

                        break;
                }

                //angular velocity
                var velAng;
                var diff = Math.max(cfg.velAngMax,cfg.velAngMin) - Math.min (cfg.velAngMax,cfg.velAngMin);
                velAng = cfg.velAngMin +this.rnd() * diff;

                pos.x += cfg.posOffsetX;
                pos.y += cfg.posOffsetY;

                vertexItems.push(pos.x,pos.y,vel.x,vel.y);
                this.drawingVectors.push( {x:pos.x,y:pos.y,vx:vel.x,vy:vel.y})

                var startTime,lifespan;

                startTime = cfg.minStartTime + this.rnd() * (cfg.maxStartTime - cfg.minStartTime);
                lifespan = cfg.minLifespan + this.rnd() * (cfg.maxLifespan - cfg.minLifespan);

                this.loopLength = Math.max(this.loopLength,startTime+lifespan);
                var cellIndex = 0;

                if (cfg.cells) {
                    var numCells = cfg.cells.length;
                    if (numCells &gt; 1) {
                        cellIndex = cfg.cells[Math.floor(this.rnd() * numCells)];
                    } else {
                        cellIndex = cfg.cells[0]
                    }
                }

                vertexItems.push(startTime,lifespan,velAng);
                var cell = this.atlas.cells[cellIndex];
                vertexItems.push(cell.x,cell.y,cell.w,cell.h);
            }

            this.glRenderer.initBatch(vertexItems);

        },
       
        
        /**
        * Instructs the renderer to draw the particles.
        * @method renderGL
        * @private
        */
        renderGL : function (gl, camera, params) {
            this.glRenderer.draw(gl,this.transform);
            
        },

        

        /**
        * Returns a point on a unit arc based on a total number of points and an index
        * @method regularPointCirclePerimeter
        * @param {number} a : the start angle of the arc
        * @param {number} b : the end angle of the ard
        * @param {number} index : the point index
        * @param {number} total : the total number of points
        * @private
        */
        regularPointCirclePerimeter : function (a,b,index,total) {
            var t = ((b - a ) / total) * index + a;
            return {x:Math.cos(t),y:Math.sin(t)};
        },

        /**
        * Returns a point on a unit arc
        * @method randomPointCirclePerimeter
        * @param {number} a : the start angle of the arc
        * @param {number} b : the end angle of the ard
        * @private
        */
        randomPointCirclePerimeter : function (a,b) {
            var t = a + ((b - a )* this.rnd());
            return {x:Math.cos(t),y:Math.sin(t)};
        },

        /**
        * Returns a point within the sector of a circle
        * @method randomPointCirclePerimeter
        * @param {number} a : the start angle of the sector
        * @param {number} b : the end angle of the sector
        * @private
        */
        randomPointCircle : function(a,b) {
            var t = a + ((b - a )* this.rnd());
            var u = this.rnd() + this.rnd();
            var r = (u &gt;1) ? 2 - u : u;
            return {x:r * Math.cos(t),y:r* Math.sin(t) };
        },

        /**
        * Returns a point within the unit square
        * @method randomPointRect
        * @private
        */
        randomPointRect : function() {
            return {x:this.rnd() -0.5 ,y:this.rnd() -0.5}
        },

        /**
        * Returns a point on the perimeter of the unit square
        * @method randomPointRectPerimeter
        * @private
        */
        randomPointRectPerimeter : function () {
            var t = this.rnd() * 4;

            if (t &lt; 1) return {x:t - 0.5,y:-0.5};
            if (t &lt; 2) return {x:0.5,y: t -1.5};
            if (t &lt; 3) return {x:t - 2.5,y:0.5};

            return {x:-0.5,y:t -3.5};
        },

        /**
        * Returns a point on a unit line based on a total number of points and an index.
        * @method regularPointLine
        * @param {number} radians : the angle of the line
        * @param {number} index : the point index
        * @param {number} total : the total number of points
        * @private
        */
        regularPointLine : function(radians,index,total) {
            var len = 1 / total * index - 0.5;
            var x = len * Math.cos(radians);
            var y = len * Math.sin(radians);
            return {x:x,y:y};
        },

        /**
        * Returns a point on a unit line.
        * @method regularPointLine
        * @param {number} radians : the angle of the line
        * @private
        */
        randomPointLine : function(radians) {
            var r = this.rnd() -0.5;
            var x = r * Math.cos(radians);
            var y = r * Math.sin(radians);
            return {x:x,y:y};
        },



};

for (var prop in protoProps) {
    Kiwi.GameObjects.StatelessParticles.prototype[prop] = protoProps[prop];

}
}());









    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
