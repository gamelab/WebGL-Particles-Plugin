<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/gameobject.js - ParticlesGL</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="ParticlesGL"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.1.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Kiwi.Plugins.ParticlesGL.html">Kiwi.Plugins.ParticlesGL</a></li>
            
                <li><a href="../classes/StatelessParticles.html">StatelessParticles</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Kiwi.html">Kiwi</a></li>
            
                <li><a href="../modules/Plugins.html">Plugins</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/gameobject.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">

/**

 * @module Kiwi
 * @submodule GameObjects
 * @main StatelessParticles
 */


/**
 * Creates a particle game object
 * @class StatelessParticles
 * @extends Kiwi.Entity
 * @constructor
 * @param {Kiwi.State} state : the state to which the game object belongs
 * @param {Kiwi.Textures.TextureAtlas} atlas : the texture for the particle object
 * @param {number} x : the x position of the game object
 * @param {number} y : the y position of the game object
 * @param {object} config : the particle configuration object
 * @public
 * @return {Kiwi.GameObjects.StatelessParticles}
 */

Kiwi.GameObjects.StatelessParticles = function(state, atlas, x, y, config){
    Kiwi.Entity.call(this,state, x, y);

    return this.constructor(state, atlas, x, y, config);

};
Kiwi.extend(Kiwi.GameObjects.StatelessParticles,Kiwi.Entity);




            
        

(function (){
    var protoProps = {

        constructor : function (state, atlas, x, y, config){
            this.config = this.buildDefaultConfig();
            if (typeof x === &quot;undefined&quot;) { x = 0; }
            if (typeof y === &quot;undefined&quot;) { y = 0; }
            if( typeof config != &quot;undefined&quot;) {
                this.mergeConfig( this.config, config );
            }
            
            this.randoms = function() {
                var arr = []
                for (var i =0;i &lt; 5000;i++) {
                    arr.push(Math.random())
                }
                return arr
            }();

            if (this.game.renderOption === Kiwi.RENDERER_WEBGL) {
                this.glRenderer = this.game.renderer.requestRendererInstance(&quot;StatelessParticleRenderer&quot;, { config: this.config });
            }

            if (typeof atlas == &quot;undefined&quot;) {
                console.error(&#x27;A Texture Atlas was not passed when instantiating a new StatelessParticles.&#x27;);
                this.willRender = false;
                this.visible = false;
                this.active = false;
                return;
            }

            //Set coordinates and texture
            this.atlas = atlas;
            this.cellIndex = this.atlas.cellIndex;
            this.width = atlas.cells[0].w;
            this.height = atlas.cells[0].h;
            this.transform.rotPointX = this.width / 2;
            this.transform.rotPointY = this.height / 2;
            this.box = this.components.add(new Kiwi.Components.Box(this, x, y, this.width, this.height));

            // Hide object until it is fully initialised by startEmitting
            this.visible = false;
        },


        /**
         * Populates a new object with default config parameters
         * @method buildDefaultConfig
         * @return {object}
         * @public
         */
        buildDefaultConfig: function()
        {
            return {
                &quot;additive&quot;: false,
                &quot;numParts&quot;: 20,
                &quot;posOffsetX&quot;: 0,
                &quot;posOffsetY&quot;: 0,
                &quot;posRadius&quot;: 50,
                &quot;posRadialStart&quot;: 4.363323129985823,
                &quot;posRadialEnd&quot;: 5.061454830783556,
                &quot;posWidth&quot;: 100,
                &quot;posHeight&quot;: 100,
                &quot;posAngle&quot;: 0,
                &quot;posLength&quot;: 100,
                &quot;posConstrainRect&quot;: true,
                &quot;posConstrainRadial&quot;: true,
                &quot;posShape&quot;: &quot;radial&quot;,
                &quot;maxVel&quot;: 100,
                &quot;minVel&quot;: 70,
                &quot;velConstrainRect&quot;: false,
                &quot;velConstrainRadial&quot;: false,
                &quot;velShape&quot;: &quot;line&quot;,
                &quot;velOffsetX&quot;: 0,
                &quot;velOffsetY&quot;: 0,
                &quot;velAngMin&quot;: -2,
                &quot;velAngMax&quot;: +2,
                &quot;velRadius&quot;: 100,
                &quot;velRadialStart&quot;: 0,
                &quot;velRadialEnd&quot;: 6.283185307179586,
                &quot;velWidth&quot;: 100,
                &quot;velHeight&quot;: 100,
                &quot;velAngle&quot;: 0,
                &quot;velLength&quot;: 30,
                &quot;angStartMin&quot;: 0,
                &quot;angStartMax&quot;: 0,
                &quot;angVelocityConform&quot;: false,
                &quot;minStartTime&quot;: 1,
                &quot;maxStartTime&quot;: 6,
                &quot;minLifespan&quot;: 3,
                &quot;maxLifespan&quot;: 5,
                &quot;gravityX&quot;: 0,
                &quot;gravityY&quot;: -50,
                &quot;startSize&quot;: 4,
                &quot;endSize&quot;: 150,
                &quot;loop&quot;: true,
                &quot;colEnvKeyframes&quot;: [
                    0.5,
                    0.6
                ],
                &quot;alpha&quot;: &quot;1&quot;,
                &quot;colEnv0&quot;: [
                    1,
                    0,
                    0
                ],
                &quot;colEnv1&quot;: [
                    1,
                    1,
                    0
                ],
                &quot;colEnv2&quot;: [
                    1,
                    1,
                    1
                ],
                &quot;colEnv3&quot;: [
                    0,
                    0,
                    0
                ],
                &quot;alphaGradient&quot;: [
                    1,
                    1,
                    1,
                    0
                ],
                &quot;alphaStops&quot;: [
                    0.3,
                    0.7
                ]
            };
        },


        /**
         * Merges config objects, overwriting the first config with all definitions in the second while preserving non-revised terms.
         * @method mergeConfig
         * @param {object} config1: The config object to modify
         * @param {object} config2: The config object to copy in
         * @public
         */
        mergeConfig: function(config1, config2) {
            for(var i in config2) {
                config1[i] = config2[i];
            }
        },


        /**
        * Returns the state of the particle effect. Either &quot;stopped&quot;,&quot;started&quot; or &quot;stopping&quot; 
        * @property state
        * @type boolean
        * @readonly
        * @public
        */
        effectState : &quot;stopped&quot;,
        
        
        /**
         * The type of object that this is.
         * @method objType
         * @return string
         * @public
         */
        objType : function () {
            return &quot;StatelessParticles&quot;;
        },

        /**
        * An array of vectors that conatains generated velocities if useDrawingVectors is true. Used by the particle editor.
        * @property drawingVectors
        * @type array
        * @private
        */
        drawingVectors : [],

        /**
        * If true, velocity vectors will be stored on particle generation. Used by the particle editor.
        * @property useDrawingVectors
        * @type boolean
        * @private
        */
        useDrawingVectors : false,

        /**
        * A function delegated to return a random number. Used by the particle editor.
        * @property rnd
        * @type function
        * @private
        */
        rnd : null,

        /**
        * If useRandoms is true, This array will contain pregenerate random numbers which will be used every new generation refresh. Used by the particle editor.
        * @property randoms
        * @type array
        * @private
        */
        randoms : [],

        /**
        * If true, pregenerate random numbers. Used by the particle editor.
        * @property useRandoms
        * @type boolean
        * @private
        */
        useRandoms : false,

        /**
        * The number of random numbers to generate if useRandoms is true.
        * @property numRandoms
        * @type number
        * @private
        */
        numRandoms: 5000,
        
        /**
        * The index of the next random number in useRandoms. Used by the particle editor.
        * @property nextRandomIndex
        * @type number
        * @private
        */
        nextRandomIndex : -1,
    
        /**
        * The maximum loop length of the system. Used for calculating the timeout when stopping emission. This is calculated when the particles are generated. It can be overridden once the emission has started.
        * @property timeoutLength
        * @type number
        * @public
        */
        timeoutLength:0,

        /**
         * Get the next random number from the randoms list. Used by the particle editor.
         * @method nextRandom
         * @return number
         * @private
         */
        nextRandom : function () {
            this.nextRandomIndex++;
            if (this.nextRandomIndex &gt;= this.numRandoms) this.nextRandomIndex =-1;
            return this.randoms[this.nextRandomIndex];
        },

        /**
         * Starts the system emitting particles. Particles will be regenerated each time.
         * @method startEmitting
         * @param {boolean} loop : Set to true for continuous looping. Overrides and updates the config loop setting. 
         * @param {boolean} removeOnComplete : if not looping, then the gameobject will destroy itself after one full emission cycle.
         * @param {number} numParts : the number of particles to generate, set on the config object - if not provided the current config value will be used 
         * @public
         */
        startEmitting : function (loop,removeOnComplete,numParts) {
            if (typeof loop === &quot;undefined&quot;) { loop = true; }
            if (typeof removeOnComplete === &quot;undefined&quot;) { removeOnComplete = false }
            if (typeof numParts === &quot;undefined&quot;) { numParts = this.config.numParts; }

            this.config.numParts = numParts;
            this.config.loop = loop;
            
            this.glRenderer.resetTime();
            this.glRenderer.resetPauseTime();
            
            this.setConfig(this.config,true,true);
                      
            if (!loop &amp;&amp; removeOnComplete) {
                this.scheduleStop( this.timeoutLength * 1000, true );
            }

            this.effectState = &quot;started&quot;;
            this.visible = true;
            clearTimeout(this._timer);
       
        },
        
        /**
         * Stops the system from emitting particles.
         * @method stopEmitting
         * @param {boolean} immediate : stops the emitter and removes any existing particles.
         * @param {boolean} remove : if true the gameobject will mark itself for removal either immediately, or after a completed cycle.  
         * @public
         */
        stopEmitting : function(immediate,remove) {
            if (typeof immediate === &quot;undefined&quot;) { immediate = false; }
            if (typeof remove === &quot;undefined&quot;) { remove = false; }

            if (this.effectState === &quot;started&quot; ) {
                if (immediate &amp;&amp; remove) {
                  this.remove();
                } else if (immediate &amp;&amp; !remove) {
                  this.effectState = &quot;stopped&quot;;
                  this.visible = false;
                } else if (!immediate &amp;&amp; !remove) {
                  this.glRenderer.pause();
                  this.effectState = &quot;stopping&quot;;
                  this.scheduleStop (this.timeoutLength * 1000,false);
                } else if (!immediate &amp;&amp; remove) {
                  this.config.loop = false;
                  this.scheduleStop(this.timeoutLength * 1000,true);
                }          
            }
        

        },

        /**
         * Schedules the particle effect to stop (discontinue rendering), and optionally marks the gameobject for removal.
         * @method scheduleStop
         * @param {number} milliseconds : the delay time in milliseconds before being marked for removal.
         * @param {boolean} remove : mark the gameobject for removal.
         * @public
         */
        scheduleStop: function (milliseconds,remove) {
            var that = this;
            clearTimeout(this._timer);
            this._timer = setTimeout(function(milliseconds) {
                that.effectState = &quot;stopped&quot;;
                that.visible = false;
                if (remove) that.remove.call(that);
            },milliseconds)
        },


        _timer: null,

        /**
         * Immediately marks the gameobject for removal.
         * @method remove
         * @public
         */
        remove : function() {
            this.glRenderer.destroy();  
            this.exists = false;
        },


        /**
        * Sets the configuration object and optionally regenerates particles and sets runtime properties.
        * @method setConfig
        * @param config {object} New configuration object
        * @param doGenerate {boolean} Immediately regenerate particles
        * @param doUniforms {boolean} Apply runtime properties.
        *	Deprecated: the shader will apply runtime properties before rendering,
        *	and this parameter only served to create errors.
        * @public
        */
        setConfig : function (config,doGenerate,doUniforms) {
            this.config = config;
            this.glRenderer.setConfig(config);
            if (doGenerate) this._generateParticles();
        },

        /**
        * Sets a property on the configuration object and optionally regenerates particles and sets runtime properties.
        * @method setConfigProp
        * @param {string} prop : the name of the property to set
        * @param {any} val: the value of the property to set
        * @param {boolean} doGenerate : immediately regenerate particles
        * @param {boolean} doUniforms : apply runtime properties
        * @public
        */
        setConfigProp : function (prop,val,doGenerate,doUniforms) {
            this.config[prop] = val;
            this.setConfig(this.config,doGenerate,doUniforms)

        },

        /**
        * Gets the configuration object. To change it, use setConfig or setConfigProp.
        * @method getConfig
        * @return {object}
        * @public
        */
        getConfig : function () {
            return this.config;
        },


        /**
        * Generates particles based on configuration object.
        * @method _generateParticles
        * @private
        */
        _generateParticles : function () {
            if (this.useRandoms)
                this.rnd = this.nextRandom;
            else
                this.rnd = Math.random;

            this.nextRandomIndex = -1;
            var vertexItems = [];
            
            var cfg = this.config;

            this.drawingVectors = [];


            for (var i =0; i &lt; cfg.numParts;i++) {
                //calculate pos
                var posSeed = {x:0,y:0};
                var pos = {x:0,y:0};
                var vel = {x:cfg.velOffsetX,y:cfg.velOffsetY};
                var velSeed = {x:0,y:0};


                switch (cfg.posShape) {
                    case &quot;radial&quot;:
                        if (cfg.posRandomRadial)
                            posSeed = (cfg.posConstrainRadial) ? this.randomPointCirclePerimeter( cfg.posRadialStart,cfg.posRadialEnd): this.randomPointCircle( cfg.posRadialStart,cfg.posRadialEnd);
                        else
                            posSeed = (cfg.posConstrainRadial) ? this.regularPointCirclePerimeter( cfg.posRadialStart,cfg.posRadialEnd,i,cfg.numParts-1): this.randomPointCircle( cfg.posRadialStart,cfg.posRadialEnd);
                        pos.x  = posSeed.x * cfg.posRadius;
                        pos.y  = posSeed.y * cfg.posRadius;

                        break;

                    case &quot;rectangle&quot;:
                        posSeed = (cfg.posConstrainRect) ? this.randomPointRectPerimeter() : this.randomPointRect();
                        pos.x += posSeed.x * cfg.posWidth;
                        pos.y += posSeed.y * cfg.posHeight;
                        break;

                    case &quot;line&quot;:
                        if (cfg.posRandomLine)
                            posSeed = this.randomPointLine(cfg.posAngle);
                        else
                            posSeed = this.regularPointLine(cfg.posAngle,i,cfg.numParts-1);
                        pos.x += posSeed.x * cfg.posLength;
                        pos.y += posSeed.y * cfg.posLength;
                        break;

                    case &quot;point&quot; :

                        break;
                }

                switch (cfg.velShape) {
                    case &quot;center&quot;:
                        var direction = posSeed;
                        var magnitude = cfg.minVel + this.rnd() * (cfg.maxVel - cfg.minVel)
                        vel.x = direction.x * magnitude ;
                        vel.y = direction.y * magnitude ;
                        break;

                    case &quot;radial&quot;:
                        if (cfg.velRandomRadial)
                            velSeed = (cfg.velConstrainRadial) ? this.randomPointCirclePerimeter( cfg.velRadialStart,cfg.velRadialEnd): this.randomPointCircle( cfg.velRadialStart,cfg.velRadialEnd);
                        else
                            velSeed = (cfg.velConstrainRadial) ? this.regularPointCirclePerimeter( cfg.velRadialStart,cfg.velRadialEnd,i,cfg.numParts-1): this.randomPointCircle( cfg.velRadialStart,cfg.velRadialEnd);

                        vel.x += velSeed.x * cfg.velRadius;
                        vel.y += velSeed.y * cfg.velRadius;

                        break;

                    case &quot;rectangle&quot;:
                        velSeed = (cfg.velConstrainRect) ? this.randomPointRectPerimeter() : this.randomPointRect();

                        vel.x += velSeed.x * cfg.velWidth;
                        vel.y += velSeed.y * cfg.velHeight;
                        break;

                    case &quot;line&quot;:
                        if (cfg.velRandomLine)
                            velSeed = this.randomPointLine(cfg.velAngle);
                        else
                            velSeed = this.regularPointLine(cfg.velAngle,i,cfg.numParts -1);
                        vel.x += velSeed.x * cfg.velLength;
                        vel.y += velSeed.y * cfg.velLength;
                        break;

                    case &quot;point&quot; :

                        break;
                }

                //angular velocity
                var velAng;
                var diff = Math.max(cfg.velAngMax,cfg.velAngMin) - Math.min (cfg.velAngMax,cfg.velAngMin);
                velAng = cfg.velAngMin +this.rnd() * diff;

                // Angular spawn parameters
                var startAng;
                var angDiff = Math.abs(cfg.angStartMax - cfg.angStartMin);
                startAng = cfg.angStartMin + this.rnd() * angDiff;
                if(cfg.angVelocityConform)
                {
                    // Base angle is based on velocity vector
                    startAng += Math.atan2( vel.y, vel.x );
                }

                pos.x += cfg.posOffsetX;
                pos.y += cfg.posOffsetY;

                vertexItems.push(pos.x,pos.y,vel.x,vel.y);
                this.drawingVectors.push( {x:pos.x,y:pos.y,vx:vel.x,vy:vel.y})

                var startTime,lifespan;

                startTime = cfg.minStartTime + this.rnd() * (cfg.maxStartTime - cfg.minStartTime);
                lifespan = cfg.minLifespan + this.rnd() * (cfg.maxLifespan - cfg.minLifespan);

                this.timeoutLength = Math.max(this.timeoutLength,startTime+lifespan);
                var cellIndex = 0;

                if (cfg.cells) {
                    var numCells = cfg.cells.length;
                    if (numCells &gt; 1) {
                        cellIndex = cfg.cells[Math.floor(this.rnd() * numCells)];
                    } else {
                        cellIndex = cfg.cells[0]
                    }
                }

                vertexItems.push(startTime,lifespan,velAng,startAng);
                var cell = this.atlas.cells[cellIndex];
                vertexItems.push(cell.x,cell.y,cell.w,cell.h);
            }

            this.glRenderer.initBatch(vertexItems);

        },
       
        
        /**
        * Instructs the renderer to draw the particles.
        * @method renderGL
        * @private
        */
        renderGL : function (gl, camera, params) {
            var m = this.transform.getConcatenatedMatrix();
            this.glRenderer.modelMatrix = new Float32Array([
                m.a,m.b,0,
                m.c,m.d,0,
                m.tx,m.ty,1
            ]);
            this.glRenderer.setWorldAngle( this.deriveWorldAngle( this.transform, camera ) );
            this.glRenderer.setTextureUniforms( gl, this.atlas );
        },


        /**
        * Computes a collapsed world rotation for the renderer.
        * @method deriveWorldAngle
        * @param {Kiwi.Geom.Transform} transform: the transform of the gameObject
        * @param {Kiwi.Camera} camera: the camera being rendered
        * @private
        */
        deriveWorldAngle: function( transform, camera ) {
            var m = transform.getConcatenatedMatrix();
            // Apply camera perspective
            m.prependMatrix( camera.transform.getConcatenatedMatrix() );
            m.prependMatrix( new Kiwi.Geom.Matrix(1, 0, 0, 1, -camera.transform.rotPointX, -camera.transform.rotPointY) );
            var worldAngle = Math.acos(m.a / (transform.scaleX * camera.transform.scaleX) );
            // acos does not distinguish between positive and negative angles, so is wrong half the time
            // However, we know that sin will always be negative when the angle is below 0 (and above -PI).
            if(Math.asin(m.b / (transform.scaleX * camera.transform.scaleX) ) &lt; 0)
                worldAngle *= -1;
            return( worldAngle );
        },

        

        /**
        * Returns a point on a unit arc based on a total number of points and an index
        * @method regularPointCirclePerimeter
        * @param {number} a : the start angle of the arc
        * @param {number} b : the end angle of the ard
        * @param {number} index : the point index
        * @param {number} total : the total number of points
        * @private
        */
        regularPointCirclePerimeter : function (a,b,index,total) {
            var t = ((b - a ) / total) * index + a;
            return {x:Math.cos(t),y:Math.sin(t)};
        },

        /**
        * Returns a point on a unit arc
        * @method randomPointCirclePerimeter
        * @param {number} a : the start angle of the arc
        * @param {number} b : the end angle of the ard
        * @private
        */
        randomPointCirclePerimeter : function (a,b) {
            var t = a + ((b - a )* this.rnd());
            return {x:Math.cos(t),y:Math.sin(t)};
        },

        /**
        * Returns a point within the sector of a circle
        * @method randomPointCirclePerimeter
        * @param {number} a : the start angle of the sector
        * @param {number} b : the end angle of the sector
        * @private
        */
        randomPointCircle : function(a,b) {
            var t = a + ((b - a )* this.rnd());
            var u = this.rnd() + this.rnd();
            var r = (u &gt;1) ? 2 - u : u;
            return {x:r * Math.cos(t),y:r* Math.sin(t) };
        },

        /**
        * Returns a point within the unit square
        * @method randomPointRect
        * @private
        */
        randomPointRect : function() {
            return {x:this.rnd() -0.5 ,y:this.rnd() -0.5}
        },

        /**
        * Returns a point on the perimeter of the unit square
        * @method randomPointRectPerimeter
        * @private
        */
        randomPointRectPerimeter : function () {
            var t = this.rnd() * 4;

            if (t &lt; 1) return {x:t - 0.5,y:-0.5};
            if (t &lt; 2) return {x:0.5,y: t -1.5};
            if (t &lt; 3) return {x:t - 2.5,y:0.5};

            return {x:-0.5,y:t -3.5};
        },

        /**
        * Returns a point on a unit line based on a total number of points and an index.
        * @method regularPointLine
        * @param {number} radians : the angle of the line
        * @param {number} index : the point index
        * @param {number} total : the total number of points
        * @private
        */
        regularPointLine : function(radians,index,total) {
            var len = 1 / total * index - 0.5;
            var x = len * Math.cos(radians);
            var y = len * Math.sin(radians);
            return {x:x,y:y};
        },

        /**
        * Returns a point on a unit line.
        * @method regularPointLine
        * @param {number} radians : the angle of the line
        * @private
        */
        randomPointLine : function(radians) {
            var r = this.rnd() -0.5;
            var x = r * Math.cos(radians);
            var y = r * Math.sin(radians);
            return {x:x,y:y};
        },



};

for (var prop in protoProps) {
    Kiwi.GameObjects.StatelessParticles.prototype[prop] = protoProps[prop];

}
}());









    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
